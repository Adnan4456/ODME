<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JtreeToGraphCreate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">SESEditor</a> &gt; <a href="index.source.html" class="el_package">odme.jtreetograph</a> &gt; <span class="el_source">JtreeToGraphCreate.java</span></div><h1>JtreeToGraphCreate.java</h1><pre class="source lang-java linenums">package odme.jtreetograph;

import static odme.jtreetograph.JtreeToGraphVariables.*;

import java.awt.Color;
import java.awt.MouseInfo;
import java.awt.Point;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Hashtable;

import javax.swing.JInternalFrame;
import javax.swing.JOptionPane;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;

<span class="nc" id="L20">import org.w3c.dom.Document;</span>

import com.mxgraph.io.mxCodec;
import com.mxgraph.model.mxCell;
import com.mxgraph.swing.mxGraphComponent;
import com.mxgraph.util.mxConstants;
import com.mxgraph.util.mxEvent;
import com.mxgraph.util.mxEventObject;
import com.mxgraph.util.mxEventSource;
import com.mxgraph.util.mxUndoManager;
import com.mxgraph.util.mxUndoableEdit;
import com.mxgraph.util.mxUtils;
import com.mxgraph.util.mxXmlUtils;
import com.mxgraph.util.mxEventSource.mxIEventListener;
import com.mxgraph.view.mxGraph;
import com.mxgraph.view.mxStylesheet;

import odme.contextmenus.GraphCellPopUp;
import odme.contextmenus.GraphPopup;
import odme.odmeeditor.DynamicTree;
import odme.odmeeditor.Main;
import odme.odmeeditor.ODMEEditor;
import odme.odmeeditor.PanelSplitor;



public class JtreeToGraphCreate {
	
	public static mxStylesheet stylesheet;

	/**
     * Under the MVC model, the JGraph class is a controller, GraphModel is a model,
     * and GraphUI is a view.
     *
     * @param frame
     */
    public static void createGraph(JInternalFrame frame) {
    	
        graph = new mxGraph();
        undoManager = new mxUndoManager();

        // setting default edge color
        graph.getStylesheet().getDefaultEdgeStyle()
                .put(mxConstants.STYLE_STROKECOLOR, mxUtils.getHexColorString(new Color(17, 138, 178)));
        graph.setCellsEditable(false);

        // creating new style
        mxStylesheet stylesheet = graph.getStylesheet();
        
        Hashtable&lt;String, Object&gt; entity = new Hashtable&lt;String, Object&gt;();
        entity.put(mxConstants.STYLE_SHAPE, mxConstants.SHAPE_RECTANGLE);
        entity.put(mxConstants.STYLE_FONTCOLOR, mxUtils.getHexColorString(Color.BLACK));
        entity.put(mxConstants.STYLE_FILLCOLOR, &quot;#FFFFFF&quot;);
        entity.put(mxConstants.STYLE_ROUNDED, true);
        entity.put(mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_BOTTOM);
        entity.put(mxConstants.STYLE_STROKECOLOR, mxUtils.getHexColorString(new Color(64, 61, 57)));
        entity.put(mxConstants.STYLE_STROKEWIDTH, 2);
        entity.put(mxConstants.STYLE_EDGE, mxUtils.getHexColorString(Color.BLACK));
        stylesheet.putCellStyle(&quot;Entity&quot;, entity);

        Hashtable&lt;String, Object&gt; multiaspect = new Hashtable&lt;String, Object&gt;();
        multiaspect.put(mxConstants.STYLE_SHAPE, mxConstants.SHAPE_IMAGE);
        multiaspect.put(mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_TOP);
        multiaspect.put(mxConstants.STYLE_FONTCOLOR, mxUtils.getHexColorString(Color.BLACK));
        
        multiaspect.put(mxConstants.STYLE_IMAGE,
                ODMEEditor.class.getClassLoader().getResource(&quot;images/multi.png&quot;));
        
        stylesheet.putCellStyle(&quot;Multiaspect&quot;, multiaspect);

        Hashtable&lt;String, Object&gt; aspect = new Hashtable&lt;String, Object&gt;();
        aspect.put(mxConstants.STYLE_SHAPE, mxConstants.SHAPE_IMAGE);
        aspect.put(mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_TOP);
        aspect.put(mxConstants.STYLE_FONTCOLOR, mxUtils.getHexColorString(Color.BLACK));
        aspect.put(mxConstants.STYLE_IMAGE,
                ODMEEditor.class.getClassLoader().getResource(&quot;images/aspect.png&quot;));
        stylesheet.putCellStyle(&quot;Aspect&quot;, aspect);

        Hashtable&lt;String, Object&gt; specialization = new Hashtable&lt;String, Object&gt;();
        specialization.put(mxConstants.STYLE_SHAPE, mxConstants.SHAPE_IMAGE);
        specialization.put(mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_TOP);
        specialization.put(mxConstants.STYLE_FONTCOLOR, mxUtils.getHexColorString(Color.BLACK));
        
        specialization.put(mxConstants.STYLE_IMAGE,
                ODMEEditor.class.getClassLoader().getResource(&quot;images/spec.png&quot;));
        
        specialization.put(mxConstants.STYLE_EDGE, mxUtils.getHexColorString(Color.BLACK));
        stylesheet.putCellStyle(&quot;Specialization&quot;, specialization);
        
        //###############
        
        Hashtable&lt;String, Object&gt; entityp = new Hashtable&lt;String, Object&gt;();
        entityp.put(mxConstants.STYLE_SHAPE, mxConstants.SHAPE_RECTANGLE);
        entityp.put(mxConstants.STYLE_FONTCOLOR, mxUtils.getHexColorString(Color.BLACK));
        entityp.put(mxConstants.STYLE_FILLCOLOR, &quot;#FFFFFF&quot;);
        entityp.put(mxConstants.STYLE_ROUNDED, true);
        entityp.put(mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_BOTTOM);
        entityp.put(mxConstants.STYLE_STROKECOLOR, mxUtils.getHexColorString(new Color(0, 128, 0)));
        entityp.put(mxConstants.STYLE_STROKEWIDTH, 2);
        entityp.put(mxConstants.STYLE_EDGE, mxUtils.getHexColorString(Color.green));
        stylesheet.putCellStyle(&quot;Entityp&quot;, entityp);


        Hashtable&lt;String, Object&gt; multiaspectp = new Hashtable&lt;String, Object&gt;();
        multiaspectp.put(mxConstants.STYLE_SHAPE, mxConstants.SHAPE_IMAGE);
        multiaspectp.put(mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_TOP);
        multiaspectp.put(mxConstants.STYLE_FONTCOLOR, mxUtils.getHexColorString(Color.BLACK));
        multiaspectp.put(mxConstants.STYLE_IMAGE,
                ODMEEditor.class.getClassLoader().getResource(&quot;images/maspectToBePruned.png&quot;));
        stylesheet.putCellStyle(&quot;Multiaspectp&quot;, multiaspectp);

        Hashtable&lt;String, Object&gt; specializationp = new Hashtable&lt;String, Object&gt;();
        specializationp.put(mxConstants.STYLE_SHAPE, mxConstants.SHAPE_IMAGE);
        specializationp.put(mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_TOP);
        specializationp.put(mxConstants.STYLE_FONTCOLOR, mxUtils.getHexColorString(Color.BLACK));
        specializationp.put(mxConstants.STYLE_IMAGE,
                ODMEEditor.class.getClassLoader().getResource(&quot;images/specializationToBePruned.png&quot;));
        specializationp.put(mxConstants.STYLE_EDGE, mxUtils.getHexColorString(Color.BLACK));
        stylesheet.putCellStyle(&quot;Specializationp&quot;, specializationp);
        
        //###############

        parent = graph.getDefaultParent();

        if (ssdFileGraph.exists()) {
            graph.getModel().beginUpdate();
            try {
                // use &quot;org.w3c.dom.Document&quot; not swing Document
<span class="nc" id="L148">                Document xml = mxXmlUtils.parseXml(mxUtils.readFile(</span>
                        ODMEEditor.fileLocation + &quot;/&quot; + ODMEEditor.projName + &quot;/&quot; + projectFileNameGraph
                        + &quot;Graph.xml&quot;));

                mxCodec codec = new mxCodec(xml);
                codec.decode(xml.getDocumentElement(), graph.getModel());
                parent = graph.getDefaultParent();
            } 
            catch (Exception ex) {
                ex.printStackTrace();
            } 
            finally {
                graph.getModel().endUpdate();
            }
        } 
        else {
            graph.getModel().beginUpdate();
            try {
                graph.insertVertex(parent, &quot;rootnode&quot;, &quot;Thing&quot;, 515, 20, 80, 30, &quot;Entity&quot;);
                graph.insertVertex(parent, &quot;hideV&quot;, &quot;End of Canvas&quot;, 0, 50000, 80, 30, &quot;Entity&quot;);
                graph.insertVertex(parent, &quot;hideH&quot;, &quot;End of Canvas&quot;, 50000, 0, 80, 30, &quot;Entity&quot;);
            } 
            finally {
                graph.getModel().endUpdate();
            }
        }
        graphComponent = new mxGraphComponent(graph);
        graphComponent.getViewport().setBackground(Color.WHITE);
        
        // undo redo settings
        mxEventSource.mxIEventListener listener = new mxEventSource.mxIEventListener() {

            @Override
            public void invoke(Object sender, mxEventObject evt) {
                // this condition is added to control subtree undo addition
                if (!ODMEEditor.undoControlForSubTree == true) {
                    undoManager.undoableEditHappened((mxUndoableEdit) evt.getProperty(&quot;edit&quot;));
                }
            }
        };

        // for undo redo
        graph.getModel().addListener(mxEvent.UNDO, listener);
        graph.getView().addListener(mxEvent.UNDO, listener);

        frame.getContentPane().add(graphComponent);

        // for edge connection event
        graph.addListener(mxEvent.CELL_CONNECTED, new mxIEventListener() {
            @Override
            public void invoke(Object sender, mxEventObject evt) {
                mxCell connectionCell = (mxCell) evt.getProperty(&quot;edge&quot;);

                lastAddedCell = (mxCell) connectionCell
                        .getSource(); // if there is no terminal cell then have to handle
            }
        });

        graphComponent.getGraphControl().addMouseListener(new MouseAdapter() {
            @SuppressWarnings(&quot;finally&quot;)
			public void mouseReleased(MouseEvent e) {
                Object cell = graphComponent.getCellAt(e.getX(), e.getY());
                currentSelectedCell = (mxCell) cell; // this for console use

                if (e.getButton() == MouseEvent.BUTTON1) {
                	
                    if (cell == null) {
                        String ob = Integer.toString(nodeNumber);
                        String nodeName = &quot;node&quot; + ob;

                        graph.getModel().beginUpdate();

                        try {
                            if (ODMEEditor.nodeAddDetector.equals(&quot;entity&quot;)) {
                                graph.insertVertex(parent, null, nodeName, e.getX() - 40, e.getY(),
                                                80, 30, &quot;Entity&quot;);
                                nodeNumber++;
                            } 
                            else if (ODMEEditor.nodeAddDetector.equals(&quot;aspect&quot;)) {
                                graph.insertVertex(parent, null, nodeName + &quot;Dec&quot;, e.getX() - 15,
                                        e.getY(), 30, 30, &quot;Aspect&quot;);
                                nodeNumber++;
                            } 
                            else if (ODMEEditor.nodeAddDetector.equals(&quot;multiaspect&quot;)) {
                                graph.insertVertex(parent, null, nodeName + &quot;MAsp&quot;, e.getX() - 15,
                                                e.getY(), 30, 30, &quot;Multiaspect&quot;);
                                nodeNumber++;
                            } 
                            else if (ODMEEditor.nodeAddDetector.equals(&quot;specialization&quot;)) {
                                graph.insertVertex(parent, null, nodeName + &quot;Spec&quot;, e.getX() - 15,
                                                e.getY(), 30, 30, &quot;Specialization&quot;);
                                nodeNumber++;
                            }
                        } 
                        finally {
                            graph.getModel().endUpdate();
                            // De-Selecting mouse selection from menu items
                            ODMEEditor.nodeAddDetector = &quot;&quot;;
                            return;
                        }
                    } 
                    else {
                        // this section is for showing variables of the selected node to the variable
                        // table
                        if (!ODMEEditor.nodeAddDetector.equals(&quot;delete&quot;)) {
                        	
                            Object showvar = graphComponent.getCellAt(e.getX(), e.getY());
                            mxCell varCell = (mxCell) showvar;
                            selectedNodeCellForVariableUpdate = varCell;
                            
                            if (varCell.isVertex()) {
                            	
                            	// double click handling
                                if (e.getClickCount() == 2) {
                                    mxCell clikedCell = (mxCell) cell;
                                    if (clikedCell.isVertex()) {
                                    	if (ODMEEditor.toolMode == &quot;ses&quot;) {
                                    		Object position = graphComponent.getCellAt(e.getX(), e.getY());
                                    		JtreeToGraphGeneral.renameCell(position);
                                    	}
                                    }
                                }
                                
                                pathToRoot.add((String) varCell.getValue());
                                JtreeToGraphConvert.nodeToRootPathVar(varCell);

                                String[] stringArray = pathToRoot.toArray(new String[0]);
                                ArrayList&lt;String&gt; pathToRootRev = new ArrayList&lt;String&gt;();

                                for (int i = stringArray.length - 1; i &gt;= 0; i--) {
                                    pathToRootRev.add(stringArray[i]);
                                }

                                String[] stringArrayRev = pathToRootRev.toArray(new String[0]);
                            
                                TreePath treePathForVariable = JtreeToGraphGeneral.getTreeNodePath(stringArrayRev);
                                if (!(treePathForVariable == null)) {
                                    DefaultMutableTreeNode currentNode =
                                            (DefaultMutableTreeNode) (treePathForVariable
                                                                              .getLastPathComponent()); // if mouse not released then some condition

                                    // -------------------------------------------------------
                                    TreeNode[] nodes = currentNode.getPath();

                                    String[] nodesToSelectedNode = new String[100];
                                    int b = 0;

                                    for (TreePath key : DynamicTree.varMap.keySet()) {
                                        int a = 0;

                                        for (String value : DynamicTree.varMap.get(key)) {
                                            DefaultMutableTreeNode currentNode2 =
                                                    (DefaultMutableTreeNode) (key.getLastPathComponent());

                                            TreeNode[] nodes2 = currentNode2.getPath();
                                            
                                            if (nodes.length == nodes2.length) {
                                            	int aa = 1;
                                                for (int i = 0; i &lt; nodes.length; i++) {
                                                    if (!nodes[i].toString().equals(nodes2[i].toString())) {
                                                    	aa = 0;
                                                    	break;
                                                    } 
                                                }
                                                a = aa;
                                            }
                                            if (a == 1) {
                                                nodesToSelectedNode[b] = value;
                                                b++;
                                            }
                                        }
                                    }

                                    nodesToSelectedNode = Arrays.stream(nodesToSelectedNode)
                                            .filter(s -&gt; (s != null &amp;&amp; s.length() &gt; 0))
                                            .toArray(String[]::new);

                                    Arrays.parallelSort(nodesToSelectedNode);

                                    ODMEEditor.scenarioVariable
                                            .showNodeValuesInTable(currentNode.toString(),
                                                    nodesToSelectedNode);
                                    
                                    variableList = nodesToSelectedNode;
                                    
                                    // -------------------------------------------------------

                                    pathToRoot.clear();

                                    // for showing constraints in the table when selecting any node from graph;
                                    ODMEEditor.treePanel.showConstraintsInTable(treePathForVariable);
                                } 
                                else {
                                    pathToRoot.clear();
                                    
                                }
                            }
                            
                            
//                            if (ODMEEditor.toolMode == &quot;ses&quot;) {
//                            	new MyKeyboardHandler(graphComponent); 
//                            	graph.addListener(mxEvent.CELLS_REMOVED, new mxIEventListener() {
//                            		@Override public void invoke(Object sender, mxEventObject evt) {
//                            			try {
//                            				Object delcell = graphComponent.getCellAt(e.getX(), e.getY());
//
//                                            if (delcell != null) {
//                                                mxCell deleteCell = (mxCell) delcell;
//
//                                                if (deleteCell.isEdge()) {
//                                                	JtreeToGraphDelete.deleteEdgeFromGraphPopup(delcell);
//                                                } 
//                                                else {
//                                                	JtreeToGraphDelete.deleteNodeFromGraphPopup(delcell);
//                                                }
//                                            }
//                            				Thread.sleep(10);
//                            			} catch (InterruptedException e1) {
//                            				e1.printStackTrace();
//                            			}
//                            		} 
//                            	});
//                            }   
                        }
                        
                        //if (SESEditor.nodeAddDetector.equals(&quot;delete&quot;)) {
                        else {
                            // this delete will not delete all the child node. becuase sometimes we need to
                            // delete
                            // only one node that time we can use this and for that we have to add another
                            // button for not synchronizing with jtree

                            Object delcell = graphComponent.getCellAt(e.getX(), e.getY());
                            if (delcell != null) {
                                mxCell deleteCell = (mxCell) delcell;

                                if (deleteCell.isEdge()) {
                                	JtreeToGraphDelete.deleteEdgeFromGraphPopup(delcell);
                                } 
                                else {
                                	JtreeToGraphDelete.deleteNodeFromGraphPopup(delcell);
                                }
                            }
                            // De-Selecting mouse selection from menu items
                            ODMEEditor.nodeAddDetector = &quot;&quot;;
                        }

                        
                    } // end of else from if cell==null

                    
                      
                    
                 // for the last added node
                    callAfterEdgeConnectionComplete();
                } // button 1 end

                // right click events using pop up menu
                // #ROY - added BUtton2 check to support laptops too
                else if (   (e.getButton() == MouseEvent.BUTTON2)
                	|| (e.getButton() == MouseEvent.BUTTON3) ) {
                	System.out.println(&quot;JTREETOGRAPH - RIGHT CLICK &quot;);
                	Object showvar = graphComponent.getCellAt(e.getX(), e.getY());
                    mxCell varCell = (mxCell) showvar;
                    selectedNodeCellForVariableUpdate = varCell;
                    
                    //------------------------------
                    if (cell != null) {
                    if (varCell.isVertex()) {
                    	
                    	// double click handling
                        if (e.getClickCount() == 2) {
                            mxCell clikedCell = (mxCell) cell;
                            if (clikedCell.isVertex()) {
                            	if (ODMEEditor.toolMode == &quot;ses&quot;) {
                            		Object position = graphComponent.getCellAt(e.getX(), e.getY());
                            		JtreeToGraphGeneral.renameCell(position);
                            	}
                            }
                        }
                        
                        pathToRoot.add((String) varCell.getValue());
                        JtreeToGraphConvert.nodeToRootPathVar(varCell);

                        String[] stringArray = pathToRoot.toArray(new String[0]);
                        ArrayList&lt;String&gt; pathToRootRev = new ArrayList&lt;String&gt;();

                        for (int i = stringArray.length - 1; i &gt;= 0; i--) {
                            pathToRootRev.add(stringArray[i]);
                        }

                        String[] stringArrayRev = pathToRootRev.toArray(new String[0]);

                        TreePath treePathForVariable = JtreeToGraphGeneral.getTreeNodePath(stringArrayRev);
                        if (!(treePathForVariable == null)) {
                            DefaultMutableTreeNode currentNode =
                                    (DefaultMutableTreeNode) (treePathForVariable
                                                                      .getLastPathComponent()); // if mouse not released then some condition

                            // -------------------------------------------------------
                            TreeNode[] nodes = currentNode.getPath();
                            String[] nodesToSelectedNode = new String[100];
                            int b = 0;
                           
                            for (TreePath key : DynamicTree.varMap.keySet()) {
                                int a = 0;

                                for (String value : DynamicTree.varMap.get(key)) {
                                    DefaultMutableTreeNode currentNode2 =
                                            (DefaultMutableTreeNode) (key.getLastPathComponent());

                                    TreeNode[] nodes2 = currentNode2.getPath();

                                    if (nodes.length == nodes2.length) {
                                           int aa = 1;
                                           for (int i = 0; i &lt; nodes.length; i++) {
                                        	   if (!nodes[i].toString().equals(nodes2[i].toString())) {
                                        		   aa = 0;
                                                   break;
                                        	   } 
                                           	}
                                            
                                           a = aa;
                                    }
                                    if (a == 1) {
                                        nodesToSelectedNode[b] = value;
                                        b++;
                                    }
                                }
                            }

                            nodesToSelectedNode = Arrays.stream(nodesToSelectedNode)
                                    .filter(s -&gt; (s != null &amp;&amp; s.length() &gt; 0))
                                    .toArray(String[]::new);

                            Arrays.parallelSort(nodesToSelectedNode);

                            ODMEEditor.scenarioVariable
                                    .showNodeValuesInTable(currentNode.toString(),
                                            nodesToSelectedNode);
                            
                            variableList = nodesToSelectedNode;
                            // -------------------------------------------------------

                            pathToRoot.clear();

                            // for showing constraints in the table when selecting any node from graph;
                            ODMEEditor.treePanel.showConstraintsInTable(treePathForVariable);
                        } 
                        else {
                            pathToRoot.clear();
                        }
                    }
                    }
                  //------------------------------
       	
                    // for fixing popup window while page is more thant monitor height
                    Point p = MouseInfo.getPointerInfo().getLocation();
                    int y = p.y;
                    int x = p.x;
                    int screenWidth = java.awt.Toolkit.getDefaultToolkit().getScreenSize().width;

                    if (x &gt; screenWidth) {
                        x = x - PanelSplitor.dividerLocation - 10 - screenWidth;
                    } 
                    else {
                        x = x - PanelSplitor.dividerLocation - 10;
                    }
                    // end of that

                    // here position will be edge or vertex on that place
                    Object position = graphComponent.getCellAt(e.getX(), e.getY());

                    // checking if there is any vertex or edge
                    if (position != null) {
                    	if (!((mxCell) position).isVertex() &amp;&amp; ODMEEditor.toolMode == &quot;pes&quot;) {}
                    	else {
                    		GraphCellPopUp graphCellPopup = new GraphCellPopUp(position);
                    		// #ROY - removed &quot;isPoppupTrigger&quot; to solve contextMenu bug
                			graphCellPopup.show(graphComponent, x, y - 104);
                    	}
                        
                    }
                    else {
                    	if (ODMEEditor.toolMode == &quot;ses&quot;) {	
                    		GraphPopup graphPopup = new GraphPopup(e.getX(), e.getY());
                    		// #ROY - removed &quot;isPoppupTrigger&quot; to solve contextMenu bug
                			graphPopup.show(graphComponent, x, y - 104);
                    	}
                    }
                }
                
            }
            // mouse event 2
        });
    }
    
<span class="nc" id="L545">    public static void callAfterEdgeConnectionComplete() {</span>
        mxCell addedCell = null;

        if (lastAddedCell != null &amp;&amp; graph.getOutgoingEdges(lastAddedCell).length &gt; 0) {
            Object[] outgoing = graph.getOutgoingEdges(lastAddedCell);
            Object targetCell = graph.getModel().getTerminal(outgoing[outgoing.length - 1], false);
            addedCell = (mxCell) targetCell;
            Object[] incoming = graph.getIncomingEdges(addedCell);

            Object lastAddedEdge = outgoing[outgoing.length - 1];
            mxCell lastEdge = (mxCell) lastAddedEdge;
            if (lastEdge.isEdge()) {
                try {
                    lastEdge.getTarget().getValue();
                } 
                catch (Exception e) {
                    graph.removeCells(new Object[] {outgoing[outgoing.length - 1]});
                    addedCell = null;
                    lastAddedCell = null;
                    return;
                }
            }

            if (lastAddedCell.getId().startsWith(&quot;uniformity&quot;)) {
                graph.removeCells(new Object[] {outgoing[outgoing.length - 1]});

                JOptionPane.showMessageDialog(Main.frame,
                        &quot;You can not add here. Add to the reference node.&quot;);

                addedCell = null;
                lastAddedCell = null;
            }

            if (incoming.length &gt; 1) {
                graph.removeCells(new Object[] {outgoing[outgoing.length - 1]});
                lastAddedCell = null;
            } 
            else {
                if (addedCell != null) {

                	JtreeToGraphConvert.nodeToRootPath(addedCell);

                    mxCell cellParentCheck = lastAddedCell;
                    lastAddedCell = null;

                    // update jtree
                    String[] stringArray = path.toArray(new String[0]);
                    ArrayList&lt;String&gt; pathRev = new ArrayList&lt;String&gt;();

                    for (int i = stringArray.length - 1; i &gt;= 0; i--) {
                        pathRev.add(stringArray[i]);
                    }

                    String[] stringArrayRev = pathRev.toArray(new String[0]);

                    // have to check if the source node is connected with any parent or not.
                    /*
                     * for (int i = stringArrayRev.length - 1; i &gt;= 0; i--) {
                     * System.out.println(stringArrayRev[i]); }
                     */

                    if (cellParentCheck != null) {
                        if (cellParentCheck.getId()
                                .equals(&quot;rootnode&quot;)) {// by using checkRootConnectivity() i can omit
                            // this section and make it only on if else.
                            // have to check later
                            if (graph.getOutgoingEdges(addedCell).length &gt; 0) {
                                // for cell who has child elements and added to some other parent as- a child
                                // node. subtree addition
                            	JtreeToGraphSave.saveModuleFromCurrentModel(cellParentCheck);
                                ODMEEditor.undoControlForSubTree = true;
                                JtreeToGraphAdd.addModuleFromSubgraph(cellParentCheck);
                                JtreeToGraphDelete.deleteNodeFromGraphPopupForSubTree(firstAddedCellForSubTreeDeletion);
                                ODMEEditor.undoControlForSubTree = false;
                                firstAddedCellForSubTreeDeletion = null;
                                firstAddedCellForSubTree = 0;

                            } else {
                            	JtreeToGraphAdd.addNodeWIthGraphAddition(addedCell.getValue().toString(),
                                        stringArrayRev);
                                // have to check subtree here
                            }
                        }
                        else {// if not root node
                        	JtreeToGraphCheck.checkRootConnectivity(cellParentCheck);

                            if (connectedToRoot) {
                                Object[] forParentCheck = graph.getIncomingEdges(cellParentCheck);
                                if (forParentCheck.length == 1) {
                                    if (graph.getOutgoingEdges(addedCell).length &gt; 0) {
                                        // for cell who has child elements and added to some other parent as a child
                                        // node. subtree creation
                                    	JtreeToGraphSave.saveModuleFromCurrentModel(cellParentCheck);
                                        ODMEEditor.undoControlForSubTree = true;
                                        JtreeToGraphAdd.addModuleFromSubgraph(cellParentCheck);
                                        JtreeToGraphDelete.deleteNodeFromGraphPopupForSubTree(firstAddedCellForSubTreeDeletion);
                                        ODMEEditor.undoControlForSubTree = false;
                                        firstAddedCellForSubTreeDeletion = null;
                                        firstAddedCellForSubTree = 0;
                                    }
                                    else {
                                    	JtreeToGraphAdd.addNodeWIthGraphAddition(addedCell.getValue().toString(),
                                                stringArrayRev);

                                        System.out.println(&quot;Tested syn now&quot;);
                                        System.out.println(&quot;cellParentCheck:&quot; + cellParentCheck.getValue());
                                        System.out.println(&quot;addedCell:&quot; + addedCell.getValue());
                                        // Synchronization with its child node while adding into main reference node
                                        JtreeToGraphCheck.checkSubtreeNodeForSync(cellParentCheck, addedCell);
                                        // have to check subtree here for adding node with same node
                                        JtreeToGraphCheck.checkSubtreeNode(addedCell);
                                    }
                                }
                            }
                            connectedToRoot = false;
                        }
                        cellParentCheck = null;
                    }
                    path.clear();
                }
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>