<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ODDManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">SESEditor</a> &gt; <a href="index.source.html" class="el_package">odme.odmeeditor</a> &gt; <span class="el_source">ODDManager.java</span></div><h1>ODDManager.java</h1><pre class="source lang-java linenums">package odme.odmeeditor;

// import static odme.odmeeditor.XmlUtils.sesview;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.*;
import java.util.ArrayList;
import java.util.List;

import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;

import javax.swing.filechooser.FileNameExtensionFilter;
<span class="nc" id="L24">import javax.xml.parsers.DocumentBuilder;</span>
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import org.xml.sax.SAXException;

import odme.jtreetograph.JtreeToGraphConvert;
import javax.swing.JFileChooser;

/**
 * ODDManager is a JPanel that shows the current ODD in a table and provides functionalities to manipulate
 * the data and the ODD themselves and also export them in Yaml and Xml
 * 
 * it has two &quot;mode&quot;s ; &quot;generate OD&quot; and &quot;ODD Manager&quot; for the first one you can only edit and optionally 
 * save the currently open project's ODD and perhaps give it a different name
 * 
 * with ODD Manager mode, you can read all the ODD's that you've previously saved and delete or export them
 * in other formats if you want
 * 
 * ODD's are saved and consumed in java's native .ser format which easily uses their table's model to build
 * a serialized format out of it. you can then read .ser files and convert them to EditableDataModel Object
 * and feed this object to the JTable which is showing all the data ; the advantage of this method is that
 * there's zero Xml/Yaml/Json overhead , + it's easier to maintain and it's java's native therefore it provides
 * superior performance compared to xml or other schemas (also people on reddit highly recommend this format for
 * such use cases; if that counts!)
 * 
 * ODD .ser files are all saved in %PROJECT_ROOT%\odd\ (which you can see in the project's root directory) 
 * @author Roy
 * */
public class ODDManager extends JPanel{
	
	static final long serialVersionUID=1l;
	
	// table headers
	private final static String[] nodeHeaders = {
		&quot;Component Name&quot;,
		&quot;Type&quot;,
		&quot;Data-Type&quot;,
		&quot;Lower Bound Value&quot;,
		&quot;Upper Bound Value&quot;,
		&quot;Comments&quot;
	};
	
<span class="nc" id="L71">	private static String getStateXsdFilePath() {</span>
		return ODMEEditor.fileLocation+System.getProperty(&quot;file.separator&quot;)+
			ODMEEditor.projName+
			System.getProperty(&quot;file.separator&quot;)+
			&quot;xsdfromxml.xsd&quot;;
	}
	
<span class="nc" id="L78">	public static final String getODDsPath() {</span>
		return ODMEEditor.fileLocation
			+System.getProperty(&quot;file.separator&quot;)
			+&quot;odd&quot;;
	}
	
	/* 
	 * 	NOTE:
	 * 	these vars are written so (indents) to 
	 *	mention how elements are structured 
	*/
	private JPanel btnsPanel;
		private JButton saveBtn;
		private JButton deleteBtn;
		private JButton exportYamlBtn;
		private JButton exportXmlBtn;
		private JLabel currentODDLabel;
		
	private JPanel oddsPanel;
		private ODDListView oddListView;
		private JPanel jtPanel;
			private JScrollPane jsp;
				private JTable jt;
				
	private String currentProjName;
	private String mode;
	// private JButton openBtn;
	
	public ODDManager() {
		this(&quot;Generate OD&quot;);
		this.currentProjName=ODMEEditor.projName;
		this.mode=mode;
	}
	
	public ODDManager(String mode){
		super();
		File f=new File(getODDsPath());
		if(!f.exists())
			f.mkdirs();
		this.setLayout(new FlowLayout());
		if (!mode.equals(&quot;Generate OD&quot;) &amp;&amp; !mode.equals(&quot;ODD Manager&quot;))
			throw new IllegalArgumentException(&quot;Only Allowed modes for ODD Manager are 'ODD Manager' and 'Generate OD'&quot;);
		init(mode);
	}
	
<span class="nc" id="L123">	private void init(String mode){</span>
		this.currentODDLabel=new JLabel();
		this.currentODDLabel.setFont(new Font(&quot;Serif&quot;, Font.BOLD, 20));
		
		this.jt=new JTable();
		this.jtPanel=new JPanel();
		this.oddsPanel=new JPanel();
		
		// making the table scrollable
		jsp=new JScrollPane(jt);
		this.add(jsp);
		jtPanel.add(this.jsp);
		this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		
		initBtnsPanel(mode);
		this.add(btnsPanel);
		this.add(currentODDLabel);
		
		// CAVEAT: if the mode is &quot;Generate ODD&quot; this still gets generated, but only
		// for the purpose of backwards-compatibility and preventing future 'null'-issues
		this.oddListView=new ODDListView(this);
		if (mode.equals(&quot;ODD Manager&quot;)) {
			// initOpenBtn(); // deprecated
			this.oddsPanel.add(this.oddListView);
			this.oddsPanel.add(jtPanel);
			this.add(oddsPanel);
		}
		else this.add(jtPanel);
		populateInitialTable(); // out of the current xsd open
		reDoTableInitials();
		updateCurrentODD(ODMEEditor.projName);
	}
	
	/**
	 * @author Roy
	 * initialize the buttons and call their corresponding init* methods
	 * which in turn will initialize that button and assing a listnere to it
	 * (so it can act on clicks) and adds it to the panel
	 * */
<span class="nc" id="L162">	private void initBtnsPanel(String mode) {</span>
		this.btnsPanel=new JPanel();
		btnsPanel.add(currentODDLabel);
		initSaveBtn();
		if (mode.equals(&quot;ODD Manager&quot;)) {
			initExportXmlBtn();
			initExportYamlBtn();
			initDeleteBtn();
		}
		btnsPanel.setLayout(new FlowLayout(FlowLayout.LEFT));
	}
	
	/**
	 * @author Roy
	 * update the name of currently open ODD
	 * */
<span class="nc" id="L178">	private void updateCurrentODD(String newODD) {</span>
		this.currentODDLabel.setText(newODD);
		this.currentProjName=newODD;
	}
	

	// ======================================================= FUNCTIONALITIES
	
	/**
	 * @author Roy
	 * Use JavaSE's classes to serialize the table's data model and write it to 
	 * a file
	 * */
<span class="nc" id="L191">	private void exportSerialized(File f) throws IOException{</span>
		FileOutputStream fos=new FileOutputStream(f);
		ObjectOutputStream oos=new ObjectOutputStream(fos);
		EditableDataModel edm=(EditableDataModel)jt.getModel();
		oos.writeObject(edm);
		oos.close();
		fos.close();
	}
	
	/**
	 * @author Roy
	 * Use JavaSE's classes to deserialize a file (specified by the path) into JTable's 
	 * data model and return it so it can be assigned to JTable
	 * */
<span class="nc" id="L205">	private EditableDataModel importSerialized(String path) throws IOException, ClassNotFoundException{</span>
		EditableDataModel dtm=null;
		FileInputStream fis=new FileInputStream(path);
        ObjectInputStream in=new ObjectInputStream(fis);
        dtm=(EditableDataModel) in.readObject();
        in.close();
        fis.close();
        return dtm;
	}
	
	/**
	 * @author Roy
	 * used by ODDListView in order to inform ODDManager when a new file is selected
	 * */
<span class="nc" id="L219">	public void readODD(String oddName){</span>
		
		if(oddName==currentProjName)return; // it's the same file - don't read again
		
		String oddPath=getODDsPath()+System.getProperty(&quot;file.separator&quot;)+oddName+&quot;.ser&quot;;
		EditableDataModel dtm=null;
		try {
			
			// there's most likely a permission problem if this error happens
			if(!new File(oddPath).exists())
				throw new IOException(&quot;'&quot;+oddPath+&quot;' does not exist!&quot;);
			updateCurrentODD(oddName); // remember which file is being read
			
			dtm=importSerialized(oddPath);
			if(dtm == null) {
				JOptionPane.showMessageDialog(
					null,&quot;Unable to Read ODD File&quot;,
					&quot;Error&quot;,JOptionPane.ERROR_MESSAGE);
				return;
			}
			jt.setModel(dtm);
			reDoTableInitials(); // gui stuff
		} catch (ClassNotFoundException | IOException e) { 
			JOptionPane.showMessageDialog(
				null, &quot;Unable to Read ODD File&quot;,&quot;Error&quot;
				,JOptionPane.ERROR_MESSAGE);
			e.printStackTrace();
		}
	}
	
	/**
	 * save the current table's DataModel as a serialized object in a file 
	 * with a custom name (asked from user)
	 * @author Roy
	 * */
<span class="nc" id="L254">	private void saveSer() {</span>
		File fOut=null;
		String filename=JOptionPane.showInputDialog(null, &quot;enter ODD's name (without the '.ser' part):&quot;,this.currentProjName);
		if(filename==null) return; // canceled
		String outPath=getODDsPath()+System.getProperty(&quot;file.separator&quot;)+filename+&quot;.ser&quot;;
		try{
			
			fOut=new File(outPath);
			if(fOut.exists()) { // bug fix - DO NOT REMOVE (I forgot what the bug was tho)
				fOut.delete();
				fOut.createNewFile();
			}
			
			exportSerialized(fOut);
			reDoTableInitials();
			this.updateCurrentODD(filename);
			oddListView.updateNames(); // tell the listview to re-read the filenames
			
			if(mode==&quot;Generate OD&quot;)javax.swing.JOptionPane.showMessageDialog(null,filename+&quot; saved.&quot;);
		}catch(IOException ioe) {
			ioe.printStackTrace();
			// javax.swing.JOptionPane.showMessageDialog(null,&quot;Could not write the serialized Object&quot;);
		}
	}
	
<span class="nc" id="L279">	private void deleteCurrentODD() {</span>
		File fdel=null;
		String delPath=getODDsPath()+System.getProperty(&quot;file.separator&quot;)+currentProjName+&quot;.ser&quot;;
		fdel=new File(delPath);
		fdel.delete(); // if the file doesn't exist - this method causes no errors
		javax.swing.JOptionPane.showMessageDialog(null,currentProjName+&quot; Deleted&quot;);
		this.oddListView.updateNames();
		
	}

	// ======================================================= BTNs
	
<span class="nc" id="L291">	private void initExportXmlBtn() {</span>
		this.exportXmlBtn=new JButton(&quot;Export XML&quot;);
		btnsPanel.add(exportXmlBtn);
		exportXmlBtn.addActionListener(new ActionListener() {
			@Override public void actionPerformed(ActionEvent ae) {
				exportMachineReadable();
			}
		});
	}
	
<span class="nc" id="L301">	private void initExportYamlBtn() {</span>
		this.exportYamlBtn=new JButton(&quot;Export YAML&quot;);
		btnsPanel.add(exportYamlBtn);
		exportYamlBtn.addActionListener(new ActionListener() {
			@Override public void actionPerformed(ActionEvent ae) {
				exportYaml();
			}
		});
	}
	
<span class="nc" id="L311">	private void initSaveBtn() {</span>
		this.saveBtn=new JButton(&quot;Save&quot;);
		btnsPanel.add(saveBtn);
		saveBtn.addActionListener(new ActionListener() {
			@Override public void actionPerformed(ActionEvent ae) {
				saveSer();
			}
		});
	}
	
<span class="nc" id="L321">	private void initDeleteBtn() {</span>
		this.deleteBtn=new JButton(&quot;Delete&quot;);
		btnsPanel.add(deleteBtn);
		deleteBtn.addActionListener(new ActionListener() {
			@Override public void actionPerformed(ActionEvent ae) {
				deleteCurrentODD();
			}
		});
	}
	
	// ======================================================= LEGACY - WORKS FINE, DON'T MODIFY UNLESS NECESSARY!
	
<span class="nc" id="L333">	public static String currentXsdToYaml() {</span>
		return xsdToYaml(getStateXsdFilePath());
	}
	
	/**
	 * @author Roy
	 * the current xsd has the state of the program
	 * */
	public static String xsdToYaml(String path) {
		String curr=&quot;&quot;;
		List&lt;String[]&gt; xsd=null;
		try {
<span class="nc" id="L345">			xsd=readXsd(path);</span>
			for (String[] row:xsd) {
				if(row[1].equals(&quot;variable&quot;))curr+=&quot;\t&quot;; // for the type &quot;node&quot; it's not supposed to be tabbed
				curr+=row[0]+&quot;:&quot;; // adding the main node/var
				if(row.length&gt;3 &amp;&amp; row[2]!=null &amp;&amp; !row[2].isEmpty())curr+=&quot;\n\t\ttype: &quot;+row[2]+&quot;\n&quot;; // type
				if(row.length&gt;=4 &amp;&amp; row[3]!=null &amp;&amp; !row[3].isEmpty())curr+=&quot;\t\tmin: &quot;+row[3]+&quot;\n&quot;; // min 
				if(row.length&gt;=5 &amp;&amp; row[4]!=null &amp;&amp; !row[4].isEmpty())curr+=&quot;\t\tmax: &quot;+row[4]; // max
				if(row.length&gt;=6 &amp;&amp; row[5]!=null &amp;&amp; !row[5].isEmpty())curr+=&quot;\t\tcomment: &quot;+row[5]; // max
				curr+=&quot;\n&quot;;
			}
		}catch(Exception e) {e.printStackTrace();}
		return curr;
	}

	 /**
     * @author Roy
     * #ROY - adding new Functionality
     * */
<span class="nc" id="L363">	private void exportMachineReadable() {</span>
		
		ODMEEditor.saveFunc(false);
		ODMEEditor.updateState();
		JtreeToGraphConvert.convertTreeToXML();
		String xmlContent=XmlUtils.readFile(
			ODMEEditor.fileLocation, 
			ODMEEditor.projName,
			&quot;xmlforxsd.xml&quot;
		);
		ODMEEditor.chooseAndSaveFile(xmlContent,ODMEEditor.projName+&quot;.xml&quot;, null); // uncomment for production
	}

<span class="nc" id="L376">	public static void chooseAndSaveFile(String content,String suggestedPath,String ext) {</span>
		FileWriter fw=null;
		try{
			fw=new FileWriter(getOpenedFile(suggestedPath));
			fw.write(content);
			javax.swing.JOptionPane.showMessageDialog(null,&quot;File Saved Successfully.&quot;);
		}catch(IOException ioe) {ioe.printStackTrace();}

		// handle leakage and canceling
		try { if(fw!=null) fw.close(); }
		catch(IOException ioe1) { ioe1.printStackTrace(); }
	}

<span class="nc" id="L389">	public static File getOpenedFile(String path) {</span>
		return getOpenedFile(path,null);
	}

<span class="nc" id="L393">	public static File getOpenedFile(String path,String ext) {</span>
		JFileChooser jfc=new JFileChooser();

		// XXX making ext ineffective for now (due to BUGS)
		if (ext!=null)
			jfc.setFileFilter(new FileNameExtensionFilter(ext,ext));

		jfc.setSelectedFile(new File(path));
		int res=jfc.showOpenDialog(null);
		if(res==JFileChooser.APPROVE_OPTION)
			return jfc.getSelectedFile();
		return null;
	}

	/**
     * @author Roy
     * #ROY - adding new Functionality : use it for a Human Readable Yaml, which is NOT
     * convertable to xsd/xml
     **/
<span class="nc" id="L412">	private void exportYaml() {</span>
		// javax.swing.JOptionPane.showMessageDialog(null,ODDManager.getODDsPath());
		ODMEEditor.saveFunc(false);
		ODMEEditor.updateState();
		JtreeToGraphConvert.convertTreeToXML();
		String yamlContent=currentXsdToYaml();
		ODMEEditor.chooseAndSaveFile(yamlContent,ODMEEditor.projName+&quot;.yaml&quot;, null); // uncomment for production
	}
	
<span class="nc" id="L421">	private void reDoTableInitials() { // this method just does some bugfix (don't ask)</span>
		
		jt.setPreferredScrollableViewportSize(new Dimension(1024,600));
		jt.getColumnModel().getColumn(0).setPreferredWidth(200);
		// getColumnModel().getColumn(1).setPreferredWidth();
		jt.setFillsViewportHeight(true);
		jt.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 20));
		jt.setRowHeight(30);
		jt.setShowVerticalLines(true);
		jt.setSelectionBackground(new Color(217, 237, 146));
		jt.setSelectionForeground(new Color(188, 71, 73));
	}
	
	/**
	 * use readCurrentXsd to read the current xsd and turn it into 
	 * suitable DataModel for JTable and then assign it to JTable
	 * */
	private void populateInitialTable() {
		
		EditableDataModel dtm=new EditableDataModel(nodeHeaders,0);
		List&lt;String[]&gt; data=null;
		try{
<span class="nc" id="L443">			data=readCurrentXsd();</span>
			
			// caveat: if user hasn't saved the whole
			// progress yet, &quot;data&quot; may be null
			for(int i=0;i&lt;data.size();i++) 
				dtm.insertRow(dtm.getRowCount(),data.get(i));
			
			// adjusting table size and font etc.
			jt.setModel(dtm);
		}catch(Exception e) {
			e.printStackTrace();
		}
	}
	
	// ======================================================= Reading inital xsd - new format with indents
	
<span class="nc" id="L459">	private static List&lt;String[]&gt; readCurrentXsd() throws SAXException, IOException, ParserConfigurationException{</span>
		return readXsd(getStateXsdFilePath());
	}

	/**
	 * @author Roy
	 * read current project's xsd and parse it (manually) to extract the data you want (that is; only the 
	 * columns like lowerBound upperBound etc.) and return a String[] list (list of arrays) so it can 
	 * be assigned to JTable 
	 */
<span class="nc" id="L469">	private static List&lt;String[]&gt; readXsd(String tablePath) throws SAXException, IOException, ParserConfigurationException {</span>
		
		// preparing the Document Object Model (DOM)
		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
	    DocumentBuilder db = dbf.newDocumentBuilder();
	    org.w3c.dom.Document doc = db.parse(new File(tablePath));
	    doc.getDocumentElement().normalize();

	    // source of data for later consumption by the JTable
	    List&lt;String[]&gt; dataSource=new ArrayList&lt;String[]&gt;();
	    List&lt;Element&gt; processed=new ArrayList&lt;Element&gt;();
	    
	    // kick start processing in a recursive manner (xsd in and of itself is recursive!)
	    NodeList nodes=doc.getElementsByTagName(&quot;xs:element&quot;);
	    processNodeList(nodes,dataSource,processed,0);
	    
	    return dataSource;
	}

	/**
	 * @author Roy
	 * processes xs:element tags at one specific level of depth and recursively calls itself
	 * if that tag has xs:element child tags, until all xs:element tags are processed
	 * */
<span class="nc" id="L493">	private static void processNodeList(NodeList nodes,List&lt;String[]&gt; src,List&lt;Element&gt; processed,int indent) {</span>
		Element curr=null;
		NodeList kids=null;
		for (int i=0;i&lt;nodes.getLength();i++) {
			curr=(Element)nodes.item(i);
			if(!processed.contains(curr)) {
				processElementTag(curr, src, indent);
				kids=curr.getElementsByTagName(&quot;xs:element&quot;);
				if(kids.getLength()&gt;0)
					processNodeList(kids, src,processed,indent+1);
				processed.add(curr);
			}
		}
	}

	 	
	/**
	 * @author Roy
	 * process one Element Tag, without touching it's children
	 * */
<span class="nc" id="L513">	private static void processElementTag(Element e,List&lt;String[]&gt; src,int indent) {</span>
		src.add(getNodeHeaders(e,indent)); // adding headers
		
		// processing xs:attribute tags under the current xs:element tag (which is e)
		NodeList attrs=e.getElementsByTagName(&quot;xs:attribute&quot;);
		indent+=2;
		Element curr=null;
		String firstParentName=null;
		for(int i=0;i&lt;attrs.getLength();i++) {
			curr=(Element)attrs.item(i);
			firstParentName=findFirstParent(curr, &quot;xs:element&quot;);
			if(firstParentName.equals(e.getAttribute(&quot;name&quot;)) &amp;&amp;
			(!curr.hasAttribute(&quot;use&quot;) || !curr.getAttribute(&quot;use&quot;).equals(&quot;optional&quot;))
			)src.add(processAttributeTag(curr, indent));
		}
	}
	
	/**
	 * @author Roy
	 * find the first parent tag of Element e, that has the tagName as its...well, tag name!
	 * */
<span class="nc" id="L534">	private static String findFirstParent(Element e,String tagName) {</span>
		Node curr=(Node)e;
		Node n=null;
		do {
			n=curr.getParentNode();
			curr=n;
		}while(n!=null &amp;&amp; !n.getNodeName().equals(tagName));
		if(n==null)return &quot;[NO_PARENT]&quot;;
		return ((Element)n).getAttribute(&quot;name&quot;);
	}
	
	/**
	 * @author Roy
	 * get a node's attributes in a consumable form (based on the child tags)
	 * */
<span class="nc" id="L549">	private static String[] processAttributeTag(Element e,int indent) {</span>
		
		String[] r=new String[6];
		r[0]=indentStr(&quot;-&quot;+e.getAttribute(&quot;name&quot;),indent);
		r[1]=&quot;Variable&quot;;
		NodeList nl=e.getElementsByTagName(&quot;*&quot;);
		Element temp;
		for(int i=0;i&lt;nl.getLength();i++) {
			temp=(Element)nl.item(i);
			switch(temp.getNodeName()) {
				case &quot;xs:restriction&quot;:r[2]=temp.getAttribute(&quot;base&quot;).replace(&quot;xs:&quot;, &quot;&quot;);break;
				case &quot;xs:minInclusive&quot;:r[3]=temp.getAttribute(&quot;value&quot;);break;
				case &quot;xs:maxInclusive&quot;:r[4]=temp.getAttribute(&quot;value&quot;);break;
				default:break;
			}
		}
		return r;
	}
	
	/**
	 * @author Roy
	 * get node name and the fact that it is a node
	 * */
<span class="nc" id="L572">	private static String[] getNodeHeaders(Element e,int indent) {</span>
		String[] r=new String[5];
		r[0]=indentStr(e.getAttribute(&quot;name&quot;),indent,&quot;  &quot;);
		r[1]=&quot;Node&quot;;
		return r;
	}
	
	/**
	 * @author Roy
	 * puts whitespaces at the start of a String
	 * */
<span class="nc" id="L583">	private static String indentStr(String s,int level) {</span>
		return indentStr(s,level,&quot; &quot;);
	}
	
	/**
	 * @author Roy
	 * puts whitespaces at the start of a String
	 * */
<span class="nc" id="L591">	private static String indentStr(String s,int level,String indentStr) {</span>
		for (int i=0;i&lt;level;i++)
			s=indentStr+s;
		return s;
	}
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>