<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeInfoWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">SESEditor</a> &gt; <a href="index.source.html" class="el_package">xml.schema</a> &gt; <span class="el_source">TypeInfoWriter.java</span></div><h1>TypeInfoWriter.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//jdk8x2r jaxp.TypeInfoWriter -xsd11 -i xsd11_datatype_test.xml
package xml.schema;

<span class="nc" id="L20">import org.w3c.dom.TypeInfo;</span>
import org.xml.sax.Attributes;
import org.xml.sax.DTDHandler;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.SAXParseException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.helpers.XMLReaderFactory;

import odme.jtreetograph.JtreeToGraphGeneral;
import odme.odmeeditor.Console;
import odme.odmeeditor.ODMEEditor;

import javax.xml.XMLConstants;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.TypeInfoProvider;
import javax.xml.validation.ValidatorHandler;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Vector;

/**
 * &lt;h1&gt;TypeInfoWriter&lt;/h1&gt;
 * &lt;p&gt;
 * Provides a trace of the schema type information for elements and attributes
 * in an XML document. XML instance of the created SES model is validated
 * against an SES XML Schema using this class. Validation result is displayed in
 * the console window of the editor as human readable format.
 * &lt;/p&gt;
 *
 * @author Michael Glavassevich, IBM
 * @version $Id: TypeInfoWriter.java 903087 2010-01-26 05:41:00Z mrglavas $
 * @ModifiedBy ---
 */
public class TypeInfoWriter extends DefaultHandler {
    /**
     * Schema full checking feature id
     * (http://apache.org/xml/features/validation/schema-full-checking).
     */
    protected static final String SCHEMA_FULL_CHECKING_FEATURE_ID =
            &quot;http://apache.org/xml/features/validation/schema-full-checking&quot;;

    /**
     * Honour all schema locations feature id
     * (http://apache.org/xml/features/honour-all-schemaLocations).
     */
    protected static final String HONOUR_ALL_SCHEMA_LOCATIONS_ID =
            &quot;http://apache.org/xml/features/honour-all-schemaLocations&quot;;

    /**
     * Validate schema annotations feature id
     * (http://apache.org/xml/features/validate-annotations)
     */
    protected static final String VALIDATE_ANNOTATIONS_ID =
            &quot;http://apache.org/xml/features/validate-annotations&quot;;

    /**
     * Generate synthetic schema annotations feature id
     * (http://apache.org/xml/features/generate-synthetic-annotations).
     */
    protected static final String GENERATE_SYNTHETIC_ANNOTATIONS_ID =
            &quot;http://apache.org/xml/features/generate-synthetic-annotations&quot;;

    /**
     * Default schema language (http://www.w3.org/2001/XMLSchema).
     */
    protected static final String DEFAULT_SCHEMA_LANGUAGE = XMLConstants.W3C_XML_SCHEMA_NS_URI;

    /**
     * XSD 1.1 schema language (http://www.w3.org/XML/XMLSchema/v1.1).
     */
    protected static final String XSD11_SCHEMA_LANGUAGE = &quot;http://www.w3.org/XML/XMLSchema/v1.1&quot;;

    /**
     * Default parser name (org.apache.xerces.parsers.SAXParser).
     */
    protected static final String DEFAULT_PARSER_NAME = &quot;org.apache.xerces.parsers.SAXParser&quot;;

    /**
     * Default schema full checking support (false).
     */
    protected static final boolean DEFAULT_SCHEMA_FULL_CHECKING = false;

    /**
     * Default honour all schema locations (false).
     */
    protected static final boolean DEFAULT_HONOUR_ALL_SCHEMA_LOCATIONS = false;

    /**
     * Default validate schema annotations (false).
     */
    protected static final boolean DEFAULT_VALIDATE_ANNOTATIONS = false;

    /**
     * Default generate synthetic schema annotations (false).
     */
    protected static final boolean DEFAULT_GENERATE_SYNTHETIC_ANNOTATIONS = false;

    /**
     * TypeInfo provider.
     */
    protected TypeInfoProvider fTypeInfoProvider;

    /**
     * Print writer.
     */
    protected PrintWriter fOut;

    /**
     * Indent level.
     */
    protected int fIndent;

    public static void validateXML() {
<span class="nc" id="L141">        XMLReader parser = null;</span>
        Vector&lt;String&gt; instances = null;
        boolean schemaFullChecking = DEFAULT_SCHEMA_FULL_CHECKING;
        boolean honourAllSchemaLocations = DEFAULT_HONOUR_ALL_SCHEMA_LOCATIONS;
        boolean validateAnnotations = DEFAULT_VALIDATE_ANNOTATIONS;
        boolean generateSyntheticAnnotations = DEFAULT_GENERATE_SYNTHETIC_ANNOTATIONS;

        // process -i: instance documents
        if (instances == null) {
            instances = new Vector&lt;String&gt;();
        }

        if (ODMEEditor.sesValidationControl == 1) {
        	String path = new String();
        	if (ODMEEditor.toolMode == &quot;ses&quot;)
        		path = ODMEEditor.fileLocation + &quot;/&quot; + ODMEEditor.projName + &quot;/xmlforxsd.xml&quot;;
        	else
        		path = ODMEEditor.fileLocation + &quot;/&quot; + ODMEEditor.currentScenario + &quot;/xmlforxsd.xml&quot;;
        	
            instances.add(path);
            ODMEEditor.sesValidationControl = 0;
        } else {
            String rootNodeName = JtreeToGraphGeneral.rootNodeName();
            
            String path = new String();
        	if (ODMEEditor.toolMode == &quot;ses&quot;)
        		path = ODMEEditor.fileLocation + &quot;/&quot; + ODMEEditor.projName + &quot;/&quot; + rootNodeName + &quot;.xml&quot;;
        	else
        		path = ODMEEditor.fileLocation + &quot;/&quot; + ODMEEditor.currentScenario + &quot;/&quot; + rootNodeName + &quot;.xml&quot;;
        	
            instances.add(path);
        }

        // use default parser?
        if (parser == null) {
            // create parser
            try {
                parser = XMLReaderFactory.createXMLReader(DEFAULT_PARSER_NAME);
            } 
            catch (Exception e) {
                Console.addConsoleOutput(&quot;error: Unable to instantiate parser (&quot; + DEFAULT_PARSER_NAME + &quot;)&quot;);
                e.printStackTrace(System.err);
                System.exit(1);
            }
        }

        try {
            // Create writer
            TypeInfoWriter writer = new TypeInfoWriter();
            writer.setOutput(System.out, &quot;UTF8&quot;);

            // Create SchemaFactory and configure
            SchemaFactory factory = SchemaFactory.newInstance(DEFAULT_SCHEMA_LANGUAGE);
            factory.setErrorHandler(writer);

            try {
                factory.setFeature(SCHEMA_FULL_CHECKING_FEATURE_ID, schemaFullChecking);
            } 
            catch (SAXNotRecognizedException e) {
                Console.addConsoleOutput(&quot;warning: SchemaFactory does not recognize feature (&quot;
                                         + SCHEMA_FULL_CHECKING_FEATURE_ID + &quot;)&quot;);
            } 
            catch (SAXNotSupportedException e) {
                Console.addConsoleOutput(
                        &quot;warning: SchemaFactory does not support feature (&quot; + SCHEMA_FULL_CHECKING_FEATURE_ID
                        + &quot;)&quot;);
            }
            try {
                factory.setFeature(HONOUR_ALL_SCHEMA_LOCATIONS_ID, honourAllSchemaLocations);
            } 
            catch (SAXNotRecognizedException e) {
                Console.addConsoleOutput(
                        &quot;warning: SchemaFactory does not recognize feature (&quot; + HONOUR_ALL_SCHEMA_LOCATIONS_ID
                        + &quot;)&quot;);
            } 
            catch (SAXNotSupportedException e) {
                Console.addConsoleOutput(
                        &quot;warning: SchemaFactory does not support feature (&quot; + HONOUR_ALL_SCHEMA_LOCATIONS_ID
                        + &quot;)&quot;);
            }
            try {
                factory.setFeature(VALIDATE_ANNOTATIONS_ID, validateAnnotations);
            } 
            catch (SAXNotRecognizedException e) {
                System.err.println(
                        &quot;warning: SchemaFactory does not recognize feature (&quot; + VALIDATE_ANNOTATIONS_ID
                        + &quot;)&quot;);
            } 
            catch (SAXNotSupportedException e) {
                Console.addConsoleOutput(
                        &quot;warning: SchemaFactory does not support feature (&quot; + VALIDATE_ANNOTATIONS_ID + &quot;)&quot;);
            }
            try {
                factory.setFeature(GENERATE_SYNTHETIC_ANNOTATIONS_ID, generateSyntheticAnnotations);
            } 
            catch (SAXNotRecognizedException e) {
                Console.addConsoleOutput(&quot;warning: SchemaFactory does not recognize feature (&quot;
                                         + GENERATE_SYNTHETIC_ANNOTATIONS_ID + &quot;)&quot;);
            } 
            catch (SAXNotSupportedException e) {
                Console.addConsoleOutput(&quot;warning: SchemaFactory does not support feature (&quot;
                                         + GENERATE_SYNTHETIC_ANNOTATIONS_ID + &quot;)&quot;);
            }

            // Build Schema from sources
            Schema schema;
            schema = factory.newSchema();

            // Setup validator and parser
            ValidatorHandler validator = schema.newValidatorHandler();
            parser.setContentHandler(validator);
            if (validator instanceof DTDHandler) {
                parser.setDTDHandler((DTDHandler) validator);
            }
            parser.setErrorHandler(writer);
            validator.setContentHandler(writer);
            validator.setErrorHandler(writer);
            writer.setTypeInfoProvider(validator.getTypeInfoProvider());

            try {
                validator.setFeature(SCHEMA_FULL_CHECKING_FEATURE_ID, schemaFullChecking);
            } 
            catch (SAXNotRecognizedException e) {
                Console.addConsoleOutput(
                        &quot;warning: Validator does not recognize feature (&quot; + SCHEMA_FULL_CHECKING_FEATURE_ID
                        + &quot;)&quot;);
            } 
            catch (SAXNotSupportedException e) {
                Console.addConsoleOutput(
                        &quot;warning: Validator does not support feature (&quot; + SCHEMA_FULL_CHECKING_FEATURE_ID
                        + &quot;)&quot;);
            }
            try {
                validator.setFeature(HONOUR_ALL_SCHEMA_LOCATIONS_ID, honourAllSchemaLocations);
            } 
            catch (SAXNotRecognizedException e) {
                Console.addConsoleOutput(
                        &quot;warning: Validator does not recognize feature (&quot; + HONOUR_ALL_SCHEMA_LOCATIONS_ID
                        + &quot;)&quot;);
            } 
            catch (SAXNotSupportedException e) {
                Console.addConsoleOutput(
                        &quot;warning: Validator does not support feature (&quot; + HONOUR_ALL_SCHEMA_LOCATIONS_ID
                        + &quot;)&quot;);
            }
            try {
                validator.setFeature(VALIDATE_ANNOTATIONS_ID, validateAnnotations);
            } 
            catch (SAXNotRecognizedException e) {
                Console.addConsoleOutput(
                        &quot;warning: Validator does not recognize feature (&quot; + VALIDATE_ANNOTATIONS_ID + &quot;)&quot;);
            } 
            catch (SAXNotSupportedException e) {
                Console.addConsoleOutput(
                        &quot;warning: Validator does not support feature (&quot; + VALIDATE_ANNOTATIONS_ID + &quot;)&quot;);
            }
            try {
                validator.setFeature(GENERATE_SYNTHETIC_ANNOTATIONS_ID, generateSyntheticAnnotations);
            } 
            catch (SAXNotRecognizedException e) {
                Console.addConsoleOutput(
                        &quot;warning: Validator does not recognize feature (&quot; + GENERATE_SYNTHETIC_ANNOTATIONS_ID
                        + &quot;)&quot;);
            } 
            catch (SAXNotSupportedException e) {
                Console.addConsoleOutput(
                        &quot;warning: Validator does not support feature (&quot; + GENERATE_SYNTHETIC_ANNOTATIONS_ID
                        + &quot;)&quot;);
            }

            // Validate instance documents and print type information
            if (instances != null &amp;&amp; instances.size() &gt; 0) {
                final int length = instances.size();
                for (int j = 0; j &lt; length; ++j) {
                    parser.parse((String) instances.elementAt(j));
                }
            }
        } 
        catch (SAXParseException e) {
        } 
        catch (Exception e) {
            Console.addConsoleOutput(&quot;error: Parse error occurred - &quot; + e.getMessage());
            if (e instanceof SAXException) {
                Exception nested = ((SAXException) e).getException();
                if (nested != null) {
                    e = nested;
                }
            }
            StringWriter errors = new StringWriter();
            e.printStackTrace(new PrintWriter(errors));
            Console.addConsoleOutput(errors.toString());
        }
    }

<span class="nc" id="L335">    public void setDocumentLocator(Locator locator) {</span>
        fIndent = 0;
        printIndent();
        Console.addConsoleOutput(&quot;setDocumentLocator(&quot;);
        Console.addConsoleOutput(&quot;systemId=&quot;);
        printQuotedString(locator.getSystemId());
        Console.addConsoleOutput(&quot;, publicId=&quot;);
        printQuotedString(locator.getPublicId());
        Console.addConsoleOutput(&quot;)&quot;);
        fOut.flush();
    }

<span class="nc" id="L347">    public void startDocument() throws SAXException {</span>
        fIndent = 0;
        printIndent();
        Console.addConsoleOutput(&quot;startDocument()&quot;);
        fOut.flush();
        fIndent++;
    }

<span class="nc" id="L355">    public void startElement(String uri, String localName, String qname, Attributes attributes)</span>
            throws SAXException {
        TypeInfo type;
        printIndent();
        Console.addConsoleOutput(&quot;startElement(&quot;);
        Console.addConsoleOutput(&quot;name=&quot;);
        printQName(uri, localName);
        Console.addConsoleOutput(&quot;,&quot;);
        Console.addConsoleOutput(&quot;type=&quot;);
        if (fTypeInfoProvider != null &amp;&amp; (type = fTypeInfoProvider.getElementTypeInfo()) != null) {
            printQName(type.getTypeNamespace(), type.getTypeName());
        } 
        else {
            Console.addConsoleOutput(&quot;null&quot;);
        }
        Console.addConsoleOutput(&quot;,&quot;);
        Console.addConsoleOutput(&quot;attributes=&quot;);
        if (attributes == null) {
            Console.addConsoleOutput(&quot;null&quot;);
        } 
        else {
            Console.addConsoleOutput(&quot;{&quot;);
            int length = attributes.getLength();
            for (int i = 0; i &lt; length; i++) {
                if (i &gt; 0) {
                    Console.addConsoleOutput(&quot;,&quot;);
                }
                String attrURI = attributes.getURI(i);
                String attrLocalName = attributes.getLocalName(i);
                Console.addConsoleOutput(&quot;{&quot;);
                Console.addConsoleOutput(&quot;name=&quot;);
                printQName(attrURI, attrLocalName);
                Console.addConsoleOutput(&quot;,&quot;);
                Console.addConsoleOutput(&quot;type=&quot;);
                if (fTypeInfoProvider != null &amp;&amp; (type = fTypeInfoProvider.getAttributeTypeInfo(i)) != null) {
                    printQName(type.getTypeNamespace(), type.getTypeName());
                } 
                else {
                    Console.addConsoleOutput(&quot;null&quot;);
                }
                Console.addConsoleOutput(&quot;,&quot;);
                Console.addConsoleOutput(&quot;id=&quot;);
                Console.addConsoleOutput(
                        fTypeInfoProvider != null &amp;&amp; fTypeInfoProvider.isIdAttribute(i) ? &quot;\&quot;true\&quot;&quot; :
                                &quot;\&quot;false\&quot;&quot;);
                Console.addConsoleOutput(&quot;,&quot;);
                Console.addConsoleOutput(&quot;specified=&quot;);
                Console.addConsoleOutput(
                        fTypeInfoProvider == null || fTypeInfoProvider.isSpecified(i) ? &quot;\&quot;true\&quot;&quot; :
                                &quot;\&quot;false\&quot;&quot;);
                Console.addConsoleOutput(&quot;}&quot;);
            }
            Console.addConsoleOutput(&quot;}&quot;);
        }
        Console.addConsoleOutput(&quot;)&quot;);
        fOut.flush();
        fIndent++;
    }

<span class="nc" id="L414">    public void endElement(String uri, String localName, String qname) throws SAXException {</span>
        fIndent--;
        printIndent();
        Console.addConsoleOutput(&quot;endElement(&quot;);
        Console.addConsoleOutput(&quot;name=&quot;);
        printQName(uri, localName);
        Console.addConsoleOutput(&quot;)&quot;);
        fOut.flush();
    }

<span class="nc" id="L424">    public void endDocument() throws SAXException {</span>
        fIndent--;
        printIndent();
        Console.addConsoleOutput(&quot;endDocument()&quot;);
        fOut.flush();
    }

<span class="nc" id="L431">    public void warning(SAXParseException ex) throws SAXException {</span>
        printError(&quot;Warning&quot;, ex);
    }

<span class="nc" id="L435">    public void error(SAXParseException ex) throws SAXException {</span>
        printError(&quot;Error&quot;, ex);
    }

<span class="nc" id="L439">    public void fatalError(SAXParseException ex) throws SAXException {</span>
        printError(&quot;Fatal Error&quot;, ex);
        throw ex;
    }

<span class="nc" id="L444">    public void setOutput(OutputStream stream, String encoding) throws UnsupportedEncodingException {</span>
        if (encoding == null) {
            encoding = &quot;UTF8&quot;;
        }
        java.io.Writer writer = new OutputStreamWriter(stream, encoding);
        fOut = new PrintWriter(writer);
    }

<span class="nc" id="L452">    protected void setTypeInfoProvider(TypeInfoProvider provider) {</span>
        fTypeInfoProvider = provider;
    }

<span class="nc" id="L456">    protected void printError(String type, SAXParseException ex) {</span>
        if (type.equals(&quot;Error&quot;)) {
            ODMEEditor.errorPresentInSES = 1;
            ODMEEditor.errorMessageInSES = ex.getMessage();
        }

        Console.addConsoleOutput(&quot;[&quot;);
        Console.addConsoleOutput(type);
        Console.addConsoleOutput(&quot;] &quot;);
        String systemId = ex.getSystemId();
        if (systemId != null) {
            int index = systemId.lastIndexOf('/');
            if (index != -1) {
                systemId = systemId.substring(index + 1);
            }
            Console.addConsoleOutput(systemId);
        }
        Console.addConsoleOutput(&quot;:&quot;);
        Console.addConsoleOutput(&quot;&quot; + ex.getLineNumber());
        Console.addConsoleOutput(&quot;&quot; + ':');
        Console.addConsoleOutput(&quot;&quot; + ex.getColumnNumber());
        Console.addConsoleOutput(&quot;: &quot;);
        Console.addConsoleOutput(ex.getMessage());
        Console.addConsoleOutput(&quot;&quot;);
    }

<span class="nc" id="L482">    protected void printIndent() {</span>
        for (int i = 0; i &lt; fIndent; i++) {
            Console.addConsoleOutput(&quot; &quot;);
        }
    }

<span class="nc" id="L488">    protected void printQName(String uri, String localName) {</span>
        if (uri != null &amp;&amp; uri.length() &gt; 0) {
            printQuotedString('{' + uri + &quot;}&quot; + localName);
            return;
        }
        printQuotedString(localName);
    }

<span class="nc" id="L496">    protected void printQuotedString(String s) {</span>
        if (s == null) {
            Console.addConsoleOutput(&quot;null&quot;);
            return;
        }
        Console.addConsoleOutput(&quot;\&quot;&quot;);
        Console.addConsoleOutput(s);
        Console.addConsoleOutput(&quot;\&quot;&quot;);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>